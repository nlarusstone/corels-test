%\documentclass[aoas,preprint]{imsart}
%\usepackage{fullpage}
%\setattribute{journal}{name}{}
%\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
%
%\usepackage{graphicx,verbatim}
%\usepackage[round]{natbib}
%\usepackage{url}
%\usepackage{amsmath,amssymb,amsthm,amsfonts}
%\usepackage{algorithm}
%\usepackage{algpseudocode}
%\usepackage{todonotes}
%\usepackage{subfig}
%\usepackage{dsfont}
%\usepackage{listings}
%\usepackage{comment}
%
%\usepackage{tikz}
%\usetikzlibrary{arrows}
%
%\input{latex_macros}
%\frenchspacing
%\hyphenation{speed-up}
%
%\begin{document}

\section{Introduction}

As machine learning continues to gain prominence in socially-important decision-making,
the interpretability of predictive models remains a crucial problem.
%
Our goal is to build models that are both highly predictive and easily understood by humans.
%
We use rule lists, also known as decision lists, to achieve this goal.
%
Rule lists are lists composed of if-then statements, which are easily interpreted; the rules give a reason for each prediction~(Figure~\ref{fig:rule-list}).

Constructing rule lists, or more generally, decision trees, has been a challenge for more than
30 years; most approaches use greedy splitting techniques~\cite{Rivest87,Breiman84,Quinlan93}. 
%
Recent approaches use Bayesian analysis, either to find a locally optimal solution~\cite{Chipman:1998jh} or to explore the search space~\citep{LethamRuMcMa15, YangRuSe16}.
%
These approaches achieve high accuracy while also managing to run reasonably quickly. However, despite the apparent accuracy of the rule lists generated by these algorithms, there is no way to determine either if the generated rule list is optimal or how close it is to optimal.

\begin{arxiv}
\begin{figure}[t!]
\begin{algorithmic}
\State \bif $(age=23-25) \wedge (priors=2-3)$ \bthen $yes$
\State \belif $(age=18-20)$ \bthen $yes$
\State \belif $(sex=male) \wedge (age=21-22)$ \bthen $yes$
\State \belif $(priors>3)$ \bthen $yes$
\State \belse $no$
\end{algorithmic}
\caption{An example rule list that predicts two-year recidivism
for the ProPublica dataset, found by CORELS.
}
\label{fig:rule-list}
\end{figure}
\end{arxiv}

Optimality is important, because there are societal implications for a lack of optimality.
%
Consider the recent ProPublica article on the COMPAS recidivism prediction tool~\citep{LarsonMaKiAn16}.
%
It highlights a case where a black-box, proprietary predictive model is being used for recidivism prediction.
%
The authors show that the COMPAS scores are racially biased, but since the model is not transparent, no one (outside of the creators of COMPAS) can determine the reason or extent of the bias~\citep{LarsonMaKiAn16}, nor can anyone determine the reason for any particular prediction.
%
By using COMPAS, users implicitly assumed that a transparent model
would not be sufficiently accurate for recidivism prediction,
\ie they assumed that a black box model would provide better accuracy.
%
We wondered whether there was indeed no transparent and sufficiently accurate model.
%
Answering this question requires solving a computationally hard problem.
%
Namely, we would like to both find a transparent model that is optimal
within a particular pre-determined class of models
and produce a certificate of its optimality.
%
This would enable one to say, for this problem and model class,
with certainty and before resorting to black box methods,
whether there exists a transparent~model.

To that end, we consider the class of rule lists assembled from pre-mined frequent itemsets
and search for an optimal rule list that minimizes a regularized risk function,~$R$.
%
This is a hard discrete optimization problem.
%
Brute force solutions that minimize~$R$ are computationally prohibitive
due to the exponential number of possible rule lists.
%
However, this is a worst case bound that is not realized in practical settings.
%
For realistic cases, it is possible to solve fairly large cases of this problem to optimality,
with the careful use of algorithms, data structures, and implementation techniques.

\begin{kdd}
\begin{figure}[b!]
\vspace{-3mm}
\begin{algorithmic}
\normalsize
\State \bif $(age=23-25) \wedge (priors=2-3)$ \bthen $yes$
\State \belif $(age=18-20)$ \bthen $yes$
\State \belif $(sex=male) \wedge (age=21-22)$ \bthen $yes$
\State \belif $(priors>3)$ \bthen $yes$
\State \belse $no$
\end{algorithmic}
\vspace{-3mm}
\caption{An example rule list that predicts two-year recidivism
for the ProPublica dataset, found by CORELS.
}
\label{fig:rule-list}
\end{figure}
\end{kdd}

We develop specialized tools from the fields of discrete optimization and artificial intelligence.
%
Specifically, we introduce a special branch-and-bound algorithm,
called Certifiably Optimal RulE ListS (CORELS), that provides
(1) the optimal solution, (2) a certificate of optimality, and (3) optionally,
a collection of near-optimal solutions and the distance between each
such solution and the optimal one.
%
The certificate of optimality means that we can investigate how close other models
(\eg models provided by greedy algorithms) are to optimal.
%
In particular, we can investigate if the rule lists from probabilistic approaches
are nearly optimal or whether those approaches sacrifice too much accuracy
in the interest of speed.

\begin{arxiv}
Within its branch-and-bound procedure, CORELS maintains a lower bound on the
minimum value of~$R$ that each incomplete rule list can achieve.
%
This allows CORELS to prune an incomplete rule list (and every possible extension)
if the bound is larger than the error of the best rule list that we've already evaluated.
%
The use of careful bounding techniques leads to massive pruning of
the search space of potential rule lists.
%
We continue to consider incomplete and complete rule lists until we have either
examined or eliminated every rule list from consideration.
%
Thus, we terminate with the optimal rule list %, the close-to-optimal rule lists,
and a certificate of optimality.
\end{arxiv}

The efficacy of CORELS depends on how much of the search space our bounds
allow us to prune; we seek a tight lower bound on~$R$.
%
The bound we maintain throughout execution is a maximum of several bounds,
that come in three categories.
%
The first category of bounds are those intrinsic to the rules themselves.
%
This category includes bounds stating that each rule must capture sufficient data;
if not, the rule list is provably non-optimal.
%
The second type of bound compares a lower bound on the value of~$R$
to that of the current best solution.
%
This allows us to exclude parts of the search space that could never be better
than our current solution.
%
Finally, our last type of bound is based on comparing incomplete rule lists that
capture the same data and and allow us to pursue only the most accurate option.
%
This last class of bounds is especially important -- without our use of a novel
\textit{symmetry-aware map}, we are unable to solve most problems of reasonable scale.
%
This symmetry-aware map keeps track of the best accuracy
for all the permutations of a given incomplete rule list.

We keep track of these bounds using a modified \emph{prefix tree},
a data structure also known as a trie.
%
Each node in the prefix tree represents an individual rule;
thus, each path in the tree represents a rule list such that
the final node in the path contains metrics about that rule list.
%
This tree structure, together with a search policy and sometimes a queue,
enables a variety of strategies, including breadth-first,
best-first, and stochastic search.
%
In particular, we can design different best-first strategies
by customizing the priority metric of a priority queue.
%
In addition, we are able to limit the number of nodes in the tree
and thereby enable tuning of space-time tradeoffs in a robust manner.
%
This tree structure is a useful way of organizing the generation
and evaluation of rule lists, and should be parallelizable.

\begin{arxiv}
We evaluated CORELS on a number of publicly available datasets.
%and have made code for our algorithm and experiments publicly available.
%
Our metric of success was 10-fold cross validated prediction accuracy on a subset of the data.
%
These datasets involve hundreds of rules and thousands of observations.
%
CORELS is generally able to find the optimal rule list in a matter of seconds
and certify it within about 10 minutes.
%
We show that we are able to achieve better out-of-sample accuracy on these
datasets than the popular greedy algorithms, CART and C4.5.
\end{arxiv}

CORELS targets large (not massive) problems,
where interpretability and certifiable optimality are important.
%
We illustrate the efficacy of our approach using (1)~the ProPublica COMPAS dataset~\cite{LarsonMaKiAn16}, for the problem of two-year recidivism prediction,
and (2)~the New York Civil Liberties Union (NYCLU) 2014 stop-and-frisk
dataset~\cite{nyclu:2014}, to predict whether a weapon will be found
on a stopped individual who is frisked or searched.
%
We produce certifiably optimal, interpretable rule lists that achieve
the same accuracy as approaches such as random forests.
%
This calls into question the need for use of a proprietary,
black box algorithm for recidivism prediction.

%\bibliographystyle{abbrvnat}
%\bibliography{refs}
%
%\end{document}
